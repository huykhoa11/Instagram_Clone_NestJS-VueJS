{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\n\n/*!\n  * message-compiler v9.2.2\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, assign, isString } from '@intlify/shared';\nconst CompileErrorCodes = {\n  // tokenizer error codes\n  EXPECTED_TOKEN: 1,\n  INVALID_TOKEN_IN_PLACEHOLDER: 2,\n  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n  UNKNOWN_ESCAPE_SEQUENCE: 4,\n  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n  UNBALANCED_CLOSING_BRACE: 6,\n  UNTERMINATED_CLOSING_BRACE: 7,\n  EMPTY_PLACEHOLDER: 8,\n  NOT_ALLOW_NEST_PLACEHOLDER: 9,\n  INVALID_LINKED_FORMAT: 10,\n  // parser error codes\n  MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n  UNEXPECTED_EMPTY_LINKED_KEY: 13,\n  UNEXPECTED_LEXICAL_ANALYSIS: 14,\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__: 15\n};\n/** @internal */\n\nconst errorMessages = {\n  // tokenizer error messages\n  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n  // parser error messages\n  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\n};\n\nfunction createCompileError(code, loc, options = {}) {\n  const {\n    domain,\n    messages,\n    args\n  } = options;\n  const msg = process.env.NODE_ENV !== 'production' ? format((messages || errorMessages)[code] || '', ...(args || [])) : code;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n\n  if (loc) {\n    error.location = loc;\n  }\n\n  error.domain = domain;\n  return error;\n}\n/** @internal */\n\n\nfunction defaultOnError(error) {\n  throw error;\n}\n\nconst LocationStub = {\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\n\nfunction createPosition(line, column, offset) {\n  return {\n    line,\n    column,\n    offset\n  };\n}\n\nfunction createLocation(start, end, source) {\n  const loc = {\n    start,\n    end\n  };\n\n  if (source != null) {\n    loc.source = source;\n  }\n\n  return loc;\n}\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\n\nfunction createScanner(str) {\n  const _buf = str;\n  let _index = 0;\n  let _line = 1;\n  let _column = 1;\n  let _peekOffset = 0;\n\n  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n\n  const isLF = index => _buf[index] === CHAR_LF;\n\n  const isPS = index => _buf[index] === CHAR_PS;\n\n  const isLS = index => _buf[index] === CHAR_LS;\n\n  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n\n  const index = () => _index;\n\n  const line = () => _line;\n\n  const column = () => _column;\n\n  const peekOffset = () => _peekOffset;\n\n  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n\n  const currentChar = () => charAt(_index);\n\n  const currentPeek = () => charAt(_index + _peekOffset);\n\n  function next() {\n    _peekOffset = 0;\n\n    if (isLineEnd(_index)) {\n      _line++;\n      _column = 0;\n    }\n\n    if (isCRLF(_index)) {\n      _index++;\n    }\n\n    _index++;\n    _column++;\n    return _buf[_index];\n  }\n\n  function peek() {\n    if (isCRLF(_index + _peekOffset)) {\n      _peekOffset++;\n    }\n\n    _peekOffset++;\n    return _buf[_index + _peekOffset];\n  }\n\n  function reset() {\n    _index = 0;\n    _line = 1;\n    _column = 1;\n    _peekOffset = 0;\n  }\n\n  function resetPeek(offset = 0) {\n    _peekOffset = offset;\n  }\n\n  function skipToPeek() {\n    const target = _index + _peekOffset; // eslint-disable-next-line no-unmodified-loop-condition\n\n    while (target !== _index) {\n      next();\n    }\n\n    _peekOffset = 0;\n  }\n\n  return {\n    index,\n    line,\n    column,\n    peekOffset,\n    charAt,\n    currentChar,\n    currentPeek,\n    next,\n    peek,\n    reset,\n    resetPeek,\n    skipToPeek\n  };\n}\n\nconst EOF = undefined;\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\n\nfunction createTokenizer(source, options = {}) {\n  const location = options.location !== false;\n\n  const _scnr = createScanner(source);\n\n  const currentOffset = () => _scnr.index();\n\n  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n\n  const _initLoc = currentPosition();\n\n  const _initOffset = currentOffset();\n\n  const _context = {\n    currentType: 14\n    /* EOF */\n    ,\n    offset: _initOffset,\n    startLoc: _initLoc,\n    endLoc: _initLoc,\n    lastType: 14\n    /* EOF */\n    ,\n    lastOffset: _initOffset,\n    lastStartLoc: _initLoc,\n    lastEndLoc: _initLoc,\n    braceNest: 0,\n    inLinked: false,\n    text: ''\n  };\n\n  const context = () => _context;\n\n  const {\n    onError\n  } = options;\n\n  function emitError(code, pos, offset, ...args) {\n    const ctx = context();\n    pos.column += offset;\n    pos.offset += offset;\n\n    if (onError) {\n      const loc = createLocation(ctx.startLoc, pos);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$1,\n        args\n      });\n      onError(err);\n    }\n  }\n\n  function getToken(context, type, value) {\n    context.endLoc = currentPosition();\n    context.currentType = type;\n    const token = {\n      type\n    };\n\n    if (location) {\n      token.loc = createLocation(context.startLoc, context.endLoc);\n    }\n\n    if (value != null) {\n      token.value = value;\n    }\n\n    return token;\n  }\n\n  const getEndToken = context => getToken(context, 14\n  /* EOF */\n  );\n\n  function eat(scnr, ch) {\n    if (scnr.currentChar() === ch) {\n      scnr.next();\n      return ch;\n    } else {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n      return '';\n    }\n  }\n\n  function peekSpaces(scnr) {\n    let buf = '';\n\n    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n      buf += scnr.currentPeek();\n      scnr.peek();\n    }\n\n    return buf;\n  }\n\n  function skipSpaces(scnr) {\n    const buf = peekSpaces(scnr);\n    scnr.skipToPeek();\n    return buf;\n  }\n\n  function isIdentifierStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 || // a-z\n    cc >= 65 && cc <= 90 || // A-Z\n    cc === 95 // _\n    ;\n  }\n\n  function isNumberStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n\n  function isNamedIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isListIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n    const ret = isNumberStart(ch);\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLiteralStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedDotStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 8\n    /* LinkedAlias */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \".\"\n    /* LinkedDot */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedModifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 9\n    /* LinkedDot */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedDelimiterStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (!(currentType === 8\n    /* LinkedAlias */\n    || currentType === 12\n    /* LinkedModifier */\n    )) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \":\"\n    /* LinkedDelimiter */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedReferStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 10\n    /* LinkedDelimiter */\n    ) {\n      return false;\n    }\n\n    const fn = () => {\n      const ch = scnr.currentPeek();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      ) {\n        return isIdentifierStart(scnr.peek());\n      } else if (ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"%\"\n      /* Modulo */\n      || ch === \"|\"\n      /* Pipe */\n      || ch === \":\"\n      /* LinkedDelimiter */\n      || ch === \".\"\n      /* LinkedDot */\n      || ch === CHAR_SP || !ch) {\n        return false;\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn();\n      } else {\n        // other characters\n        return isIdentifierStart(ch);\n      }\n    };\n\n    const ret = fn();\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isPluralStart(scnr) {\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"|\"\n    /* Pipe */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function detectModuloStart(scnr) {\n    const spaces = peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"%\"\n    /* Modulo */\n    && scnr.peek() === \"{\"\n    /* BraceLeft */\n    ;\n    scnr.resetPeek();\n    return {\n      isModulo: ret,\n      hasSpace: spaces.length > 0\n    };\n  }\n\n  function isTextStart(scnr, reset = true) {\n    const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n      const ch = scnr.currentPeek();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      ) {\n        return prev === \"%\"\n        /* Modulo */\n        ? false : hasSpace;\n      } else if (ch === \"@\"\n      /* LinkedAlias */\n      || !ch) {\n        return prev === \"%\"\n        /* Modulo */\n        ? true : hasSpace;\n      } else if (ch === \"%\"\n      /* Modulo */\n      ) {\n        scnr.peek();\n        return fn(hasSpace, \"%\"\n        /* Modulo */\n        , true);\n      } else if (ch === \"|\"\n      /* Pipe */\n      ) {\n        return prev === \"%\"\n        /* Modulo */\n        || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);\n      } else if (ch === CHAR_SP) {\n        scnr.peek();\n        return fn(true, CHAR_SP, detectModulo);\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn(true, CHAR_LF, detectModulo);\n      } else {\n        return true;\n      }\n    };\n\n    const ret = fn();\n    reset && scnr.resetPeek();\n    return ret;\n  }\n\n  function takeChar(scnr, fn) {\n    const ch = scnr.currentChar();\n\n    if (ch === EOF) {\n      return EOF;\n    }\n\n    if (fn(ch)) {\n      scnr.next();\n      return ch;\n    }\n\n    return null;\n  }\n\n  function takeIdentifierChar(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 97 && cc <= 122 || // a-z\n      cc >= 65 && cc <= 90 || // A-Z\n      cc >= 48 && cc <= 57 || // 0-9\n      cc === 95 || // _\n      cc === 36 // $\n      ;\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function takeDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57; // 0-9\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function takeHexDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57 || // 0-9\n      cc >= 65 && cc <= 70 || // A-F\n      cc >= 97 && cc <= 102; // a-f\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function getDigits(scnr) {\n    let ch = '';\n    let num = '';\n\n    while (ch = takeDigit(scnr)) {\n      num += ch;\n    }\n\n    return num;\n  }\n\n  function readModulo(scnr) {\n    skipSpaces(scnr);\n    const ch = scnr.currentChar();\n\n    if (ch !== \"%\"\n    /* Modulo */\n    ) {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n    }\n\n    scnr.next();\n    return \"%\"\n    /* Modulo */\n    ;\n  }\n\n  function readText(scnr) {\n    let buf = '';\n\n    while (true) {\n      const ch = scnr.currentChar();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      || ch === \"}\"\n      /* BraceRight */\n      || ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"|\"\n      /* Pipe */\n      || !ch) {\n        break;\n      } else if (ch === \"%\"\n      /* Modulo */\n      ) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else {\n          break;\n        }\n      } else if (ch === CHAR_SP || ch === CHAR_LF) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else if (isPluralStart(scnr)) {\n          break;\n        } else {\n          buf += ch;\n          scnr.next();\n        }\n      } else {\n        buf += ch;\n        scnr.next();\n      }\n    }\n\n    return buf;\n  }\n\n  function readNamedIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let name = '';\n\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n\n    return name;\n  }\n\n  function readListIdentifier(scnr) {\n    skipSpaces(scnr);\n    let value = '';\n\n    if (scnr.currentChar() === '-') {\n      scnr.next();\n      value += `-${getDigits(scnr)}`;\n    } else {\n      value += getDigits(scnr);\n    }\n\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n\n    return value;\n  }\n\n  function readLiteral(scnr) {\n    skipSpaces(scnr);\n    eat(scnr, `\\'`);\n    let ch = '';\n    let literal = '';\n\n    const fn = x => x !== LITERAL_DELIMITER && x !== CHAR_LF;\n\n    while (ch = takeChar(scnr, fn)) {\n      if (ch === '\\\\') {\n        literal += readEscapeSequence(scnr);\n      } else {\n        literal += ch;\n      }\n    }\n\n    const current = scnr.currentChar();\n\n    if (current === CHAR_LF || current === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0); // TODO: Is it correct really?\n\n      if (current === CHAR_LF) {\n        scnr.next();\n        eat(scnr, `\\'`);\n      }\n\n      return literal;\n    }\n\n    eat(scnr, `\\'`);\n    return literal;\n  }\n\n  function readEscapeSequence(scnr) {\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case '\\\\':\n      case `\\'`:\n        scnr.next();\n        return `\\\\${ch}`;\n\n      case 'u':\n        return readUnicodeEscapeSequence(scnr, ch, 4);\n\n      case 'U':\n        return readUnicodeEscapeSequence(scnr, ch, 6);\n\n      default:\n        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n        return '';\n    }\n  }\n\n  function readUnicodeEscapeSequence(scnr, unicode, digits) {\n    eat(scnr, unicode);\n    let sequence = '';\n\n    for (let i = 0; i < digits; i++) {\n      const ch = takeHexDigit(scnr);\n\n      if (!ch) {\n        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n        break;\n      }\n\n      sequence += ch;\n    }\n\n    return `\\\\${unicode}${sequence}`;\n  }\n\n  function readInvalidIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let identifiers = '';\n\n    const closure = ch => ch !== \"{\"\n    /* BraceLeft */\n    && ch !== \"}\"\n    /* BraceRight */\n    && ch !== CHAR_SP && ch !== CHAR_LF;\n\n    while (ch = takeChar(scnr, closure)) {\n      identifiers += ch;\n    }\n\n    return identifiers;\n  }\n\n  function readLinkedModifier(scnr) {\n    let ch = '';\n    let name = '';\n\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n\n    return name;\n  }\n\n  function readLinkedRefer(scnr) {\n    const fn = (detect = false, buf) => {\n      const ch = scnr.currentChar();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      || ch === \"%\"\n      /* Modulo */\n      || ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"|\"\n      /* Pipe */\n      || !ch) {\n        return buf;\n      } else if (ch === CHAR_SP) {\n        return buf;\n      } else if (ch === CHAR_LF) {\n        buf += ch;\n        scnr.next();\n        return fn(detect, buf);\n      } else {\n        buf += ch;\n        scnr.next();\n        return fn(true, buf);\n      }\n    };\n\n    return fn(false, '');\n  }\n\n  function readPlural(scnr) {\n    skipSpaces(scnr);\n    const plural = eat(scnr, \"|\"\n    /* Pipe */\n    );\n    skipSpaces(scnr);\n    return plural;\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readTokenInPlaceholder(scnr, context) {\n    let token = null;\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case \"{\"\n      /* BraceLeft */\n      :\n        if (context.braceNest >= 1) {\n          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n        }\n\n        scnr.next();\n        token = getToken(context, 2\n        /* BraceLeft */\n        , \"{\"\n        /* BraceLeft */\n        );\n        skipSpaces(scnr);\n        context.braceNest++;\n        return token;\n\n      case \"}\"\n      /* BraceRight */\n      :\n        if (context.braceNest > 0 && context.currentType === 2\n        /* BraceLeft */\n        ) {\n          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n        }\n\n        scnr.next();\n        token = getToken(context, 3\n        /* BraceRight */\n        , \"}\"\n        /* BraceRight */\n        );\n        context.braceNest--;\n        context.braceNest > 0 && skipSpaces(scnr);\n\n        if (context.inLinked && context.braceNest === 0) {\n          context.inLinked = false;\n        }\n\n        return token;\n\n      case \"@\"\n      /* LinkedAlias */\n      :\n        if (context.braceNest > 0) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n\n        token = readTokenInLinked(scnr, context) || getEndToken(context);\n        context.braceNest = 0;\n        return token;\n\n      default:\n        let validNamedIdentifier = true;\n        let validListIdentifier = true;\n        let validLiteral = true;\n\n        if (isPluralStart(scnr)) {\n          if (context.braceNest > 0) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          }\n\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (context.braceNest > 0 && (context.currentType === 5\n        /* Named */\n        || context.currentType === 6\n        /* List */\n        || context.currentType === 7\n        /* Literal */\n        )) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          context.braceNest = 0;\n          return readToken(scnr, context);\n        }\n\n        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {\n          token = getToken(context, 5\n          /* Named */\n          , readNamedIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (validListIdentifier = isListIdentifierStart(scnr, context)) {\n          token = getToken(context, 6\n          /* List */\n          , readListIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (validLiteral = isLiteralStart(scnr, context)) {\n          token = getToken(context, 7\n          /* Literal */\n          , readLiteral(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n          token = getToken(context, 13\n          /* InvalidPlace */\n          , readInvalidIdentifier(scnr));\n          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n          skipSpaces(scnr);\n          return token;\n        }\n\n        break;\n    }\n\n    return token;\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readTokenInLinked(scnr, context) {\n    const {\n      currentType\n    } = context;\n    let token = null;\n    const ch = scnr.currentChar();\n\n    if ((currentType === 8\n    /* LinkedAlias */\n    || currentType === 9\n    /* LinkedDot */\n    || currentType === 12\n    /* LinkedModifier */\n    || currentType === 10\n    /* LinkedDelimiter */\n    ) && (ch === CHAR_LF || ch === CHAR_SP)) {\n      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n    }\n\n    switch (ch) {\n      case \"@\"\n      /* LinkedAlias */\n      :\n        scnr.next();\n        token = getToken(context, 8\n        /* LinkedAlias */\n        , \"@\"\n        /* LinkedAlias */\n        );\n        context.inLinked = true;\n        return token;\n\n      case \".\"\n      /* LinkedDot */\n      :\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 9\n        /* LinkedDot */\n        , \".\"\n        /* LinkedDot */\n        );\n\n      case \":\"\n      /* LinkedDelimiter */\n      :\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 10\n        /* LinkedDelimiter */\n        , \":\"\n        /* LinkedDelimiter */\n        );\n\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {\n          skipSpaces(scnr);\n          return readTokenInLinked(scnr, context);\n        }\n\n        if (isLinkedModifierStart(scnr, context)) {\n          skipSpaces(scnr);\n          return getToken(context, 12\n          /* LinkedModifier */\n          , readLinkedModifier(scnr));\n        }\n\n        if (isLinkedReferStart(scnr, context)) {\n          skipSpaces(scnr);\n\n          if (ch === \"{\"\n          /* BraceLeft */\n          ) {\n            // scan the placeholder\n            return readTokenInPlaceholder(scnr, context) || token;\n          } else {\n            return getToken(context, 11\n            /* LinkedKey */\n            , readLinkedRefer(scnr));\n          }\n        }\n\n        if (currentType === 8\n        /* LinkedAlias */\n        ) {\n          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n\n        context.braceNest = 0;\n        context.inLinked = false;\n        return readToken(scnr, context);\n    }\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readToken(scnr, context) {\n    let token = {\n      type: 14\n      /* EOF */\n\n    };\n\n    if (context.braceNest > 0) {\n      return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n    }\n\n    if (context.inLinked) {\n      return readTokenInLinked(scnr, context) || getEndToken(context);\n    }\n\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case \"{\"\n      /* BraceLeft */\n      :\n        return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n\n      case \"}\"\n      /* BraceRight */\n      :\n        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n        scnr.next();\n        return getToken(context, 3\n        /* BraceRight */\n        , \"}\"\n        /* BraceRight */\n        );\n\n      case \"@\"\n      /* LinkedAlias */\n      :\n        return readTokenInLinked(scnr, context) || getEndToken(context);\n\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        const {\n          isModulo,\n          hasSpace\n        } = detectModuloStart(scnr);\n\n        if (isModulo) {\n          return hasSpace ? getToken(context, 0\n          /* Text */\n          , readText(scnr)) : getToken(context, 4\n          /* Modulo */\n          , readModulo(scnr));\n        }\n\n        if (isTextStart(scnr)) {\n          return getToken(context, 0\n          /* Text */\n          , readText(scnr));\n        }\n\n        break;\n    }\n\n    return token;\n  }\n\n  function nextToken() {\n    const {\n      currentType,\n      offset,\n      startLoc,\n      endLoc\n    } = _context;\n    _context.lastType = currentType;\n    _context.lastOffset = offset;\n    _context.lastStartLoc = startLoc;\n    _context.lastEndLoc = endLoc;\n    _context.offset = currentOffset();\n    _context.startLoc = currentPosition();\n\n    if (_scnr.currentChar() === EOF) {\n      return getToken(_context, 14\n      /* EOF */\n      );\n    }\n\n    return readToken(_scnr, _context);\n  }\n\n  return {\n    nextToken,\n    currentOffset,\n    currentPosition,\n    context\n  };\n}\n\nconst ERROR_DOMAIN = 'parser'; // Backslash backslash, backslash quote, uHHHH, UHHHHHH.\n\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\n\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n  switch (match) {\n    case `\\\\\\\\`:\n      return `\\\\`;\n\n    case `\\\\\\'`:\n      return `\\'`;\n\n    default:\n      {\n        const codePoint = parseInt(codePoint4 || codePoint6, 16);\n\n        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n          return String.fromCodePoint(codePoint);\n        } // invalid ...\n        // Replace them with U+FFFD REPLACEMENT CHARACTER.\n\n\n        return '�';\n      }\n  }\n}\n\nfunction createParser(options = {}) {\n  const location = options.location !== false;\n  const {\n    onError\n  } = options;\n\n  function emitError(tokenzer, code, start, offset, ...args) {\n    const end = tokenzer.currentPosition();\n    end.offset += offset;\n    end.column += offset;\n\n    if (onError) {\n      const loc = createLocation(start, end);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN,\n        args\n      });\n      onError(err);\n    }\n  }\n\n  function startNode(type, offset, loc) {\n    const node = {\n      type,\n      start: offset,\n      end: offset\n    };\n\n    if (location) {\n      node.loc = {\n        start: loc,\n        end: loc\n      };\n    }\n\n    return node;\n  }\n\n  function endNode(node, offset, pos, type) {\n    node.end = offset;\n\n    if (type) {\n      node.type = type;\n    }\n\n    if (location && node.loc) {\n      node.loc.end = pos;\n    }\n  }\n\n  function parseText(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(3\n    /* Text */\n    , context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseList(tokenizer, index) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(5\n    /* List */\n    , offset, loc);\n    node.index = parseInt(index, 10);\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseNamed(tokenizer, key) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(4\n    /* Named */\n    , offset, loc);\n    node.key = key;\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLiteral(tokenizer, value) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(9\n    /* Literal */\n    , offset, loc);\n    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLinkedModifier(tokenizer) {\n    const token = tokenizer.nextToken();\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get linked dot loc\n\n    const node = startNode(8\n    /* LinkedModifier */\n    , offset, loc);\n\n    if (token.type !== 12\n    /* LinkedModifier */\n    ) {\n      // empty modifier\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n      node.value = '';\n      endNode(node, offset, loc);\n      return {\n        nextConsumeToken: token,\n        node\n      };\n    } // check token\n\n\n    if (token.value == null) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n\n    node.value = token.value || '';\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node\n    };\n  }\n\n  function parseLinkedKey(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(7\n    /* LinkedKey */\n    , context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLinked(tokenizer) {\n    const context = tokenizer.context();\n    const linkedNode = startNode(6\n    /* Linked */\n    , context.offset, context.startLoc);\n    let token = tokenizer.nextToken();\n\n    if (token.type === 9\n    /* LinkedDot */\n    ) {\n      const parsed = parseLinkedModifier(tokenizer);\n      linkedNode.modifier = parsed.node;\n      token = parsed.nextConsumeToken || tokenizer.nextToken();\n    } // asset check token\n\n\n    if (token.type !== 10\n    /* LinkedDelimiter */\n    ) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n\n    token = tokenizer.nextToken(); // skip brace left\n\n    if (token.type === 2\n    /* BraceLeft */\n    ) {\n      token = tokenizer.nextToken();\n    }\n\n    switch (token.type) {\n      case 11\n      /* LinkedKey */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n        break;\n\n      case 5\n      /* Named */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseNamed(tokenizer, token.value || '');\n        break;\n\n      case 6\n      /* List */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseList(tokenizer, token.value || '');\n        break;\n\n      case 7\n      /* Literal */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseLiteral(tokenizer, token.value || '');\n        break;\n\n      default:\n        // empty key\n        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n        const nextContext = tokenizer.context();\n        const emptyLinkedKeyNode = startNode(7\n        /* LinkedKey */\n        , nextContext.offset, nextContext.startLoc);\n        emptyLinkedKeyNode.value = '';\n        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n        linkedNode.key = emptyLinkedKeyNode;\n        endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n        return {\n          nextConsumeToken: token,\n          node: linkedNode\n        };\n    }\n\n    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: linkedNode\n    };\n  }\n\n  function parseMessage(tokenizer) {\n    const context = tokenizer.context();\n    const startOffset = context.currentType === 1\n    /* Pipe */\n    ? tokenizer.currentOffset() : context.offset;\n    const startLoc = context.currentType === 1\n    /* Pipe */\n    ? context.endLoc : context.startLoc;\n    const node = startNode(2\n    /* Message */\n    , startOffset, startLoc);\n    node.items = [];\n    let nextToken = null;\n\n    do {\n      const token = nextToken || tokenizer.nextToken();\n      nextToken = null;\n\n      switch (token.type) {\n        case 0\n        /* Text */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseText(tokenizer, token.value || ''));\n          break;\n\n        case 6\n        /* List */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseList(tokenizer, token.value || ''));\n          break;\n\n        case 5\n        /* Named */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseNamed(tokenizer, token.value || ''));\n          break;\n\n        case 7\n        /* Literal */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseLiteral(tokenizer, token.value || ''));\n          break;\n\n        case 8\n        /* LinkedAlias */\n        :\n          const parsed = parseLinked(tokenizer);\n          node.items.push(parsed.node);\n          nextToken = parsed.nextConsumeToken || null;\n          break;\n      }\n    } while (context.currentType !== 14\n    /* EOF */\n    && context.currentType !== 1\n    /* Pipe */\n    ); // adjust message node loc\n\n\n    const endOffset = context.currentType === 1\n    /* Pipe */\n    ? context.lastOffset : tokenizer.currentOffset();\n    const endLoc = context.currentType === 1\n    /* Pipe */\n    ? context.lastEndLoc : tokenizer.currentPosition();\n    endNode(node, endOffset, endLoc);\n    return node;\n  }\n\n  function parsePlural(tokenizer, offset, loc, msgNode) {\n    const context = tokenizer.context();\n    let hasEmptyMessage = msgNode.items.length === 0;\n    const node = startNode(1\n    /* Plural */\n    , offset, loc);\n    node.cases = [];\n    node.cases.push(msgNode);\n\n    do {\n      const msg = parseMessage(tokenizer);\n\n      if (!hasEmptyMessage) {\n        hasEmptyMessage = msg.items.length === 0;\n      }\n\n      node.cases.push(msg);\n    } while (context.currentType !== 14\n    /* EOF */\n    );\n\n    if (hasEmptyMessage) {\n      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n    }\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseResource(tokenizer) {\n    const context = tokenizer.context();\n    const {\n      offset,\n      startLoc\n    } = context;\n    const msgNode = parseMessage(tokenizer);\n\n    if (context.currentType === 14\n    /* EOF */\n    ) {\n      return msgNode;\n    } else {\n      return parsePlural(tokenizer, offset, startLoc, msgNode);\n    }\n  }\n\n  function parse(source) {\n    const tokenizer = createTokenizer(source, assign({}, options));\n    const context = tokenizer.context();\n    const node = startNode(0\n    /* Resource */\n    , context.offset, context.startLoc);\n\n    if (location && node.loc) {\n      node.loc.source = source;\n    }\n\n    node.body = parseResource(tokenizer); // assert whether achieved to EOF\n\n    if (context.currentType !== 14\n    /* EOF */\n    ) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n    }\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  return {\n    parse\n  };\n}\n\nfunction getTokenCaption(token) {\n  if (token.type === 14\n  /* EOF */\n  ) {\n    return 'EOF';\n  }\n\n  const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n  return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n  const _context = {\n    ast,\n    helpers: new Set()\n  };\n\n  const context = () => _context;\n\n  const helper = name => {\n    _context.helpers.add(name);\n\n    return name;\n  };\n\n  return {\n    context,\n    helper\n  };\n}\n\nfunction traverseNodes(nodes, transformer) {\n  for (let i = 0; i < nodes.length; i++) {\n    traverseNode(nodes[i], transformer);\n  }\n}\n\nfunction traverseNode(node, transformer) {\n  // TODO: if we need pre-hook of transform, should be implemented to here\n  switch (node.type) {\n    case 1\n    /* Plural */\n    :\n      traverseNodes(node.cases, transformer);\n      transformer.helper(\"plural\"\n      /* PLURAL */\n      );\n      break;\n\n    case 2\n    /* Message */\n    :\n      traverseNodes(node.items, transformer);\n      break;\n\n    case 6\n    /* Linked */\n    :\n      const linked = node;\n      traverseNode(linked.key, transformer);\n      transformer.helper(\"linked\"\n      /* LINKED */\n      );\n      transformer.helper(\"type\"\n      /* TYPE */\n      );\n      break;\n\n    case 5\n    /* List */\n    :\n      transformer.helper(\"interpolate\"\n      /* INTERPOLATE */\n      );\n      transformer.helper(\"list\"\n      /* LIST */\n      );\n      break;\n\n    case 4\n    /* Named */\n    :\n      transformer.helper(\"interpolate\"\n      /* INTERPOLATE */\n      );\n      transformer.helper(\"named\"\n      /* NAMED */\n      );\n      break;\n  } // TODO: if we need post-hook of transform, should be implemented to here\n\n} // transform AST\n\n\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n  const transformer = createTransformer(ast);\n  transformer.helper(\"normalize\"\n  /* NORMALIZE */\n  ); // traverse\n\n  ast.body && traverseNode(ast.body, transformer); // set meta information\n\n  const context = transformer.context();\n  ast.helpers = Array.from(context.helpers);\n}\n\nfunction createCodeGenerator(ast, options) {\n  const {\n    sourceMap,\n    filename,\n    breakLineCode,\n    needIndent: _needIndent\n  } = options;\n  const _context = {\n    source: ast.loc.source,\n    filename,\n    code: '',\n    column: 1,\n    line: 1,\n    offset: 0,\n    map: undefined,\n    breakLineCode,\n    needIndent: _needIndent,\n    indentLevel: 0\n  };\n\n  const context = () => _context;\n\n  function push(code, node) {\n    _context.code += code;\n  }\n\n  function _newline(n, withBreakLine = true) {\n    const _breakLineCode = withBreakLine ? breakLineCode : '';\n\n    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n  }\n\n  function indent(withNewLine = true) {\n    const level = ++_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n\n  function deindent(withNewLine = true) {\n    const level = --_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n\n  function newline() {\n    _newline(_context.indentLevel);\n  }\n\n  const helper = key => `_${key}`;\n\n  const needIndent = () => _context.needIndent;\n\n  return {\n    context,\n    push,\n    indent,\n    deindent,\n    newline,\n    helper,\n    needIndent\n  };\n}\n\nfunction generateLinkedNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  generator.push(`${helper(\"linked\"\n  /* LINKED */\n  )}(`);\n  generateNode(generator, node.key);\n\n  if (node.modifier) {\n    generator.push(`, `);\n    generateNode(generator, node.modifier);\n    generator.push(`, _type`);\n  } else {\n    generator.push(`, undefined, _type`);\n  }\n\n  generator.push(`)`);\n}\n\nfunction generateMessageNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  generator.push(`${helper(\"normalize\"\n  /* NORMALIZE */\n  )}([`);\n  generator.indent(needIndent());\n  const length = node.items.length;\n\n  for (let i = 0; i < length; i++) {\n    generateNode(generator, node.items[i]);\n\n    if (i === length - 1) {\n      break;\n    }\n\n    generator.push(', ');\n  }\n\n  generator.deindent(needIndent());\n  generator.push('])');\n}\n\nfunction generatePluralNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n\n  if (node.cases.length > 1) {\n    generator.push(`${helper(\"plural\"\n    /* PLURAL */\n    )}([`);\n    generator.indent(needIndent());\n    const length = node.cases.length;\n\n    for (let i = 0; i < length; i++) {\n      generateNode(generator, node.cases[i]);\n\n      if (i === length - 1) {\n        break;\n      }\n\n      generator.push(', ');\n    }\n\n    generator.deindent(needIndent());\n    generator.push(`])`);\n  }\n}\n\nfunction generateResource(generator, node) {\n  if (node.body) {\n    generateNode(generator, node.body);\n  } else {\n    generator.push('null');\n  }\n}\n\nfunction generateNode(generator, node) {\n  const {\n    helper\n  } = generator;\n\n  switch (node.type) {\n    case 0\n    /* Resource */\n    :\n      generateResource(generator, node);\n      break;\n\n    case 1\n    /* Plural */\n    :\n      generatePluralNode(generator, node);\n      break;\n\n    case 2\n    /* Message */\n    :\n      generateMessageNode(generator, node);\n      break;\n\n    case 6\n    /* Linked */\n    :\n      generateLinkedNode(generator, node);\n      break;\n\n    case 8\n    /* LinkedModifier */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 7\n    /* LinkedKey */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 5\n    /* List */\n    :\n      generator.push(`${helper(\"interpolate\"\n      /* INTERPOLATE */\n      )}(${helper(\"list\"\n      /* LIST */\n      )}(${node.index}))`, node);\n      break;\n\n    case 4\n    /* Named */\n    :\n      generator.push(`${helper(\"interpolate\"\n      /* INTERPOLATE */\n      )}(${helper(\"named\"\n      /* NAMED */\n      )}(${JSON.stringify(node.key)}))`, node);\n      break;\n\n    case 9\n    /* Literal */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 3\n    /* Text */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`unhandled codegen node type: ${node.type}`);\n      }\n\n  }\n} // generate code from AST\n\n\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n  const mode = isString(options.mode) ? options.mode : 'normal';\n  const filename = isString(options.filename) ? options.filename : 'message.intl';\n  const sourceMap = !!options.sourceMap; // prettier-ignore\n\n  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\\n';\n  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n  const helpers = ast.helpers || [];\n  const generator = createCodeGenerator(ast, {\n    mode,\n    filename,\n    sourceMap,\n    breakLineCode,\n    needIndent\n  });\n  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n  generator.indent(needIndent);\n\n  if (helpers.length > 0) {\n    generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\n    generator.newline();\n  }\n\n  generator.push(`return `);\n  generateNode(generator, ast);\n  generator.deindent(needIndent);\n  generator.push(`}`);\n  const {\n    code,\n    map\n  } = generator.context();\n  return {\n    ast,\n    code,\n    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  };\n};\n\nfunction baseCompile(source, options = {}) {\n  const assignedOptions = assign({}, options); // parse source codes\n\n  const parser = createParser(assignedOptions);\n  const ast = parser.parse(source); // transform ASTs\n\n  transform(ast, assignedOptions); // generate javascript codes\n\n  return generate(ast, assignedOptions);\n}\n\nexport { CompileErrorCodes, ERROR_DOMAIN, LocationStub, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, errorMessages };","map":{"version":3,"names":["format","assign","isString","CompileErrorCodes","EXPECTED_TOKEN","INVALID_TOKEN_IN_PLACEHOLDER","UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER","UNKNOWN_ESCAPE_SEQUENCE","INVALID_UNICODE_ESCAPE_SEQUENCE","UNBALANCED_CLOSING_BRACE","UNTERMINATED_CLOSING_BRACE","EMPTY_PLACEHOLDER","NOT_ALLOW_NEST_PLACEHOLDER","INVALID_LINKED_FORMAT","MUST_HAVE_MESSAGES_IN_PLURAL","UNEXPECTED_EMPTY_LINKED_MODIFIER","UNEXPECTED_EMPTY_LINKED_KEY","UNEXPECTED_LEXICAL_ANALYSIS","__EXTEND_POINT__","errorMessages","createCompileError","code","loc","options","domain","messages","args","msg","process","env","NODE_ENV","error","SyntaxError","String","location","defaultOnError","LocationStub","start","line","column","offset","end","createPosition","createLocation","source","CHAR_SP","CHAR_CR","CHAR_LF","CHAR_LS","fromCharCode","CHAR_PS","createScanner","str","_buf","_index","_line","_column","_peekOffset","isCRLF","index","isLF","isPS","isLS","isLineEnd","peekOffset","charAt","currentChar","currentPeek","next","peek","reset","resetPeek","skipToPeek","target","EOF","undefined","LITERAL_DELIMITER","ERROR_DOMAIN$1","createTokenizer","_scnr","currentOffset","currentPosition","_initLoc","_initOffset","_context","currentType","startLoc","endLoc","lastType","lastOffset","lastStartLoc","lastEndLoc","braceNest","inLinked","text","context","onError","emitError","pos","ctx","err","getToken","type","value","token","getEndToken","eat","scnr","ch","peekSpaces","buf","skipSpaces","isIdentifierStart","cc","charCodeAt","isNumberStart","isNamedIdentifierStart","ret","isListIdentifierStart","isLiteralStart","isLinkedDotStart","isLinkedModifierStart","isLinkedDelimiterStart","isLinkedReferStart","fn","isPluralStart","detectModuloStart","spaces","isModulo","hasSpace","length","isTextStart","prev","detectModulo","takeChar","takeIdentifierChar","closure","takeDigit","takeHexDigit","getDigits","num","readModulo","readText","readNamedIdentifier","name","readListIdentifier","readLiteral","literal","x","readEscapeSequence","current","readUnicodeEscapeSequence","unicode","digits","sequence","i","readInvalidIdentifier","identifiers","readLinkedModifier","readLinkedRefer","detect","readPlural","plural","readTokenInPlaceholder","readTokenInLinked","validNamedIdentifier","validListIdentifier","validLiteral","readToken","nextToken","ERROR_DOMAIN","KNOWN_ESCAPES","fromEscapeSequence","match","codePoint4","codePoint6","codePoint","parseInt","fromCodePoint","createParser","tokenzer","startNode","node","endNode","parseText","tokenizer","parseList","parseNamed","key","parseLiteral","replace","parseLinkedModifier","nextConsumeToken","getTokenCaption","parseLinkedKey","parseLinked","linkedNode","parsed","modifier","nextContext","emptyLinkedKeyNode","parseMessage","startOffset","items","push","endOffset","parsePlural","msgNode","hasEmptyMessage","cases","parseResource","parse","body","slice","createTransformer","ast","helpers","Set","helper","add","traverseNodes","nodes","transformer","traverseNode","linked","transform","Array","from","createCodeGenerator","sourceMap","filename","breakLineCode","needIndent","_needIndent","map","indentLevel","_newline","n","withBreakLine","_breakLineCode","repeat","indent","withNewLine","level","deindent","newline","generateLinkedNode","generator","generateNode","generateMessageNode","generatePluralNode","generateResource","JSON","stringify","Error","generate","mode","s","join","toJSON","baseCompile","assignedOptions","parser"],"sources":["E:/LapTrinh/NestJS/social-media-clone/frontend/node_modules/@intlify/message-compiler/dist/message-compiler.esm-bundler.js"],"sourcesContent":["/*!\n  * message-compiler v9.2.2\n  * (c) 2022 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, assign, isString } from '@intlify/shared';\n\nconst CompileErrorCodes = {\r\n    // tokenizer error codes\r\n    EXPECTED_TOKEN: 1,\r\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\r\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\r\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\r\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\r\n    UNBALANCED_CLOSING_BRACE: 6,\r\n    UNTERMINATED_CLOSING_BRACE: 7,\r\n    EMPTY_PLACEHOLDER: 8,\r\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\r\n    INVALID_LINKED_FORMAT: 10,\r\n    // parser error codes\r\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\r\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\r\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\r\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\r\n    // Special value for higher-order compilers to pick up the last code\r\n    // to avoid collision of error codes. This should always be kept as the last\r\n    // item.\r\n    __EXTEND_POINT__: 15\r\n};\r\n/** @internal */\r\nconst errorMessages = {\r\n    // tokenizer error messages\r\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\r\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\r\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\r\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\r\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\r\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\r\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\r\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\r\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\r\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\r\n    // parser error messages\r\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\r\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\r\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\r\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\r\n};\r\nfunction createCompileError(code, loc, options = {}) {\r\n    const { domain, messages, args } = options;\r\n    const msg = (process.env.NODE_ENV !== 'production')\r\n        ? format((messages || errorMessages)[code] || '', ...(args || []))\r\n        : code;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    if (loc) {\r\n        error.location = loc;\r\n    }\r\n    error.domain = domain;\r\n    return error;\r\n}\r\n/** @internal */\r\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\n\nconst LocationStub = {\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createPosition(line, column, offset) {\r\n    return { line, column, offset };\r\n}\r\nfunction createLocation(start, end, source) {\r\n    const loc = { start, end };\r\n    if (source != null) {\r\n        loc.source = source;\r\n    }\r\n    return loc;\r\n}\n\nconst CHAR_SP = ' ';\r\nconst CHAR_CR = '\\r';\r\nconst CHAR_LF = '\\n';\r\nconst CHAR_LS = String.fromCharCode(0x2028);\r\nconst CHAR_PS = String.fromCharCode(0x2029);\r\nfunction createScanner(str) {\r\n    const _buf = str;\r\n    let _index = 0;\r\n    let _line = 1;\r\n    let _column = 1;\r\n    let _peekOffset = 0;\r\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\r\n    const isLF = (index) => _buf[index] === CHAR_LF;\r\n    const isPS = (index) => _buf[index] === CHAR_PS;\r\n    const isLS = (index) => _buf[index] === CHAR_LS;\r\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\r\n    const index = () => _index;\r\n    const line = () => _line;\r\n    const column = () => _column;\r\n    const peekOffset = () => _peekOffset;\r\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\r\n    const currentChar = () => charAt(_index);\r\n    const currentPeek = () => charAt(_index + _peekOffset);\r\n    function next() {\r\n        _peekOffset = 0;\r\n        if (isLineEnd(_index)) {\r\n            _line++;\r\n            _column = 0;\r\n        }\r\n        if (isCRLF(_index)) {\r\n            _index++;\r\n        }\r\n        _index++;\r\n        _column++;\r\n        return _buf[_index];\r\n    }\r\n    function peek() {\r\n        if (isCRLF(_index + _peekOffset)) {\r\n            _peekOffset++;\r\n        }\r\n        _peekOffset++;\r\n        return _buf[_index + _peekOffset];\r\n    }\r\n    function reset() {\r\n        _index = 0;\r\n        _line = 1;\r\n        _column = 1;\r\n        _peekOffset = 0;\r\n    }\r\n    function resetPeek(offset = 0) {\r\n        _peekOffset = offset;\r\n    }\r\n    function skipToPeek() {\r\n        const target = _index + _peekOffset;\r\n        // eslint-disable-next-line no-unmodified-loop-condition\r\n        while (target !== _index) {\r\n            next();\r\n        }\r\n        _peekOffset = 0;\r\n    }\r\n    return {\r\n        index,\r\n        line,\r\n        column,\r\n        peekOffset,\r\n        charAt,\r\n        currentChar,\r\n        currentPeek,\r\n        next,\r\n        peek,\r\n        reset,\r\n        resetPeek,\r\n        skipToPeek\r\n    };\r\n}\n\nconst EOF = undefined;\r\nconst LITERAL_DELIMITER = \"'\";\r\nconst ERROR_DOMAIN$1 = 'tokenizer';\r\nfunction createTokenizer(source, options = {}) {\r\n    const location = options.location !== false;\r\n    const _scnr = createScanner(source);\r\n    const currentOffset = () => _scnr.index();\r\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\r\n    const _initLoc = currentPosition();\r\n    const _initOffset = currentOffset();\r\n    const _context = {\r\n        currentType: 14 /* EOF */,\r\n        offset: _initOffset,\r\n        startLoc: _initLoc,\r\n        endLoc: _initLoc,\r\n        lastType: 14 /* EOF */,\r\n        lastOffset: _initOffset,\r\n        lastStartLoc: _initLoc,\r\n        lastEndLoc: _initLoc,\r\n        braceNest: 0,\r\n        inLinked: false,\r\n        text: ''\r\n    };\r\n    const context = () => _context;\r\n    const { onError } = options;\r\n    function emitError(code, pos, offset, ...args) {\r\n        const ctx = context();\r\n        pos.column += offset;\r\n        pos.offset += offset;\r\n        if (onError) {\r\n            const loc = createLocation(ctx.startLoc, pos);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN$1,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function getToken(context, type, value) {\r\n        context.endLoc = currentPosition();\r\n        context.currentType = type;\r\n        const token = { type };\r\n        if (location) {\r\n            token.loc = createLocation(context.startLoc, context.endLoc);\r\n        }\r\n        if (value != null) {\r\n            token.value = value;\r\n        }\r\n        return token;\r\n    }\r\n    const getEndToken = (context) => getToken(context, 14 /* EOF */);\r\n    function eat(scnr, ch) {\r\n        if (scnr.currentChar() === ch) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        else {\r\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\r\n            return '';\r\n        }\r\n    }\r\n    function peekSpaces(scnr) {\r\n        let buf = '';\r\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\r\n            buf += scnr.currentPeek();\r\n            scnr.peek();\r\n        }\r\n        return buf;\r\n    }\r\n    function skipSpaces(scnr) {\r\n        const buf = peekSpaces(scnr);\r\n        scnr.skipToPeek();\r\n        return buf;\r\n    }\r\n    function isIdentifierStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return ((cc >= 97 && cc <= 122) || // a-z\r\n            (cc >= 65 && cc <= 90) || // A-Z\r\n            cc === 95 // _\r\n        );\r\n    }\r\n    function isNumberStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return cc >= 48 && cc <= 57; // 0-9\r\n    }\r\n    function isNamedIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isListIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\r\n        const ret = isNumberStart(ch);\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLiteralStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDotStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 8 /* LinkedAlias */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \".\" /* LinkedDot */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedModifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 9 /* LinkedDot */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDelimiterStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (!(currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 12 /* LinkedModifier */)) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \":\" /* LinkedDelimiter */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedReferStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 10 /* LinkedDelimiter */) {\r\n            return false;\r\n        }\r\n        const fn = () => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === \"{\" /* BraceLeft */) {\r\n                return isIdentifierStart(scnr.peek());\r\n            }\r\n            else if (ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"%\" /* Modulo */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                ch === \":\" /* LinkedDelimiter */ ||\r\n                ch === \".\" /* LinkedDot */ ||\r\n                ch === CHAR_SP ||\r\n                !ch) {\r\n                return false;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn();\r\n            }\r\n            else {\r\n                // other characters\r\n                return isIdentifierStart(ch);\r\n            }\r\n        };\r\n        const ret = fn();\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isPluralStart(scnr) {\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \"|\" /* Pipe */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function detectModuloStart(scnr) {\r\n        const spaces = peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \"%\" /* Modulo */ &&\r\n            scnr.peek() === \"{\" /* BraceLeft */;\r\n        scnr.resetPeek();\r\n        return {\r\n            isModulo: ret,\r\n            hasSpace: spaces.length > 0\r\n        };\r\n    }\r\n    function isTextStart(scnr, reset = true) {\r\n        const fn = (hasSpace = false, prev = '', detectModulo = false) => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === \"{\" /* BraceLeft */) {\r\n                return prev === \"%\" /* Modulo */ ? false : hasSpace;\r\n            }\r\n            else if (ch === \"@\" /* LinkedAlias */ || !ch) {\r\n                return prev === \"%\" /* Modulo */ ? true : hasSpace;\r\n            }\r\n            else if (ch === \"%\" /* Modulo */) {\r\n                scnr.peek();\r\n                return fn(hasSpace, \"%\" /* Modulo */, true);\r\n            }\r\n            else if (ch === \"|\" /* Pipe */) {\r\n                return prev === \"%\" /* Modulo */ || detectModulo\r\n                    ? true\r\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_SP, detectModulo);\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_LF, detectModulo);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        };\r\n        const ret = fn();\r\n        reset && scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function takeChar(scnr, fn) {\r\n        const ch = scnr.currentChar();\r\n        if (ch === EOF) {\r\n            return EOF;\r\n        }\r\n        if (fn(ch)) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        return null;\r\n    }\r\n    function takeIdentifierChar(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 97 && cc <= 122) || // a-z\r\n                (cc >= 65 && cc <= 90) || // A-Z\r\n                (cc >= 48 && cc <= 57) || // 0-9\r\n                cc === 95 || // _\r\n                cc === 36 // $\r\n            );\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return cc >= 48 && cc <= 57; // 0-9\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeHexDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 48 && cc <= 57) || // 0-9\r\n                (cc >= 65 && cc <= 70) || // A-F\r\n                (cc >= 97 && cc <= 102)); // a-f\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function getDigits(scnr) {\r\n        let ch = '';\r\n        let num = '';\r\n        while ((ch = takeDigit(scnr))) {\r\n            num += ch;\r\n        }\r\n        return num;\r\n    }\r\n    function readModulo(scnr) {\r\n        skipSpaces(scnr);\r\n        const ch = scnr.currentChar();\r\n        if (ch !== \"%\" /* Modulo */) {\r\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\r\n        }\r\n        scnr.next();\r\n        return \"%\" /* Modulo */;\r\n    }\r\n    function readText(scnr) {\r\n        let buf = '';\r\n        while (true) {\r\n            const ch = scnr.currentChar();\r\n            if (ch === \"{\" /* BraceLeft */ ||\r\n                ch === \"}\" /* BraceRight */ ||\r\n                ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                !ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"%\" /* Modulo */) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n                else if (isPluralStart(scnr)) {\r\n                    break;\r\n                }\r\n                else {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n    function readNamedIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = '';\r\n        let name = '';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n        }\r\n        return name;\r\n    }\r\n    function readListIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let value = '';\r\n        if (scnr.currentChar() === '-') {\r\n            scnr.next();\r\n            value += `-${getDigits(scnr)}`;\r\n        }\r\n        else {\r\n            value += getDigits(scnr);\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n        }\r\n        return value;\r\n    }\r\n    function readLiteral(scnr) {\r\n        skipSpaces(scnr);\r\n        eat(scnr, `\\'`);\r\n        let ch = '';\r\n        let literal = '';\r\n        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, fn))) {\r\n            if (ch === '\\\\') {\r\n                literal += readEscapeSequence(scnr);\r\n            }\r\n            else {\r\n                literal += ch;\r\n            }\r\n        }\r\n        const current = scnr.currentChar();\r\n        if (current === CHAR_LF || current === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\r\n            // TODO: Is it correct really?\r\n            if (current === CHAR_LF) {\r\n                scnr.next();\r\n                eat(scnr, `\\'`);\r\n            }\r\n            return literal;\r\n        }\r\n        eat(scnr, `\\'`);\r\n        return literal;\r\n    }\r\n    function readEscapeSequence(scnr) {\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case '\\\\':\r\n            case `\\'`:\r\n                scnr.next();\r\n                return `\\\\${ch}`;\r\n            case 'u':\r\n                return readUnicodeEscapeSequence(scnr, ch, 4);\r\n            case 'U':\r\n                return readUnicodeEscapeSequence(scnr, ch, 6);\r\n            default:\r\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\r\n                return '';\r\n        }\r\n    }\r\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\r\n        eat(scnr, unicode);\r\n        let sequence = '';\r\n        for (let i = 0; i < digits; i++) {\r\n            const ch = takeHexDigit(scnr);\r\n            if (!ch) {\r\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\r\n                break;\r\n            }\r\n            sequence += ch;\r\n        }\r\n        return `\\\\${unicode}${sequence}`;\r\n    }\r\n    function readInvalidIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = '';\r\n        let identifiers = '';\r\n        const closure = (ch) => ch !== \"{\" /* BraceLeft */ &&\r\n            ch !== \"}\" /* BraceRight */ &&\r\n            ch !== CHAR_SP &&\r\n            ch !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, closure))) {\r\n            identifiers += ch;\r\n        }\r\n        return identifiers;\r\n    }\r\n    function readLinkedModifier(scnr) {\r\n        let ch = '';\r\n        let name = '';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        return name;\r\n    }\r\n    function readLinkedRefer(scnr) {\r\n        const fn = (detect = false, buf) => {\r\n            const ch = scnr.currentChar();\r\n            if (ch === \"{\" /* BraceLeft */ ||\r\n                ch === \"%\" /* Modulo */ ||\r\n                ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                !ch) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(detect, buf);\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(true, buf);\r\n            }\r\n        };\r\n        return fn(false, '');\r\n    }\r\n    function readPlural(scnr) {\r\n        skipSpaces(scnr);\r\n        const plural = eat(scnr, \"|\" /* Pipe */);\r\n        skipSpaces(scnr);\r\n        return plural;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInPlaceholder(scnr, context) {\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \"{\" /* BraceLeft */:\r\n                if (context.braceNest >= 1) {\r\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 2 /* BraceLeft */, \"{\" /* BraceLeft */);\r\n                skipSpaces(scnr);\r\n                context.braceNest++;\r\n                return token;\r\n            case \"}\" /* BraceRight */:\r\n                if (context.braceNest > 0 &&\r\n                    context.currentType === 2 /* BraceLeft */) {\r\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\r\n                context.braceNest--;\r\n                context.braceNest > 0 && skipSpaces(scnr);\r\n                if (context.inLinked && context.braceNest === 0) {\r\n                    context.inLinked = false;\r\n                }\r\n                return token;\r\n            case \"@\" /* LinkedAlias */:\r\n                if (context.braceNest > 0) {\r\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                }\r\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\r\n                context.braceNest = 0;\r\n                return token;\r\n            default:\r\n                let validNamedIdentifier = true;\r\n                let validListIdentifier = true;\r\n                let validLiteral = true;\r\n                if (isPluralStart(scnr)) {\r\n                    if (context.braceNest > 0) {\r\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                    }\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (context.braceNest > 0 &&\r\n                    (context.currentType === 5 /* Named */ ||\r\n                        context.currentType === 6 /* List */ ||\r\n                        context.currentType === 7 /* Literal */)) {\r\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                    context.braceNest = 0;\r\n                    return readToken(scnr, context);\r\n                }\r\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 5 /* Named */, readNamedIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 6 /* List */, readListIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validLiteral = isLiteralStart(scnr, context))) {\r\n                    token = getToken(context, 7 /* Literal */, readLiteral(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\r\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\r\n                    token = getToken(context, 13 /* InvalidPlace */, readInvalidIdentifier(scnr));\r\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInLinked(scnr, context) {\r\n        const { currentType } = context;\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        if ((currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 9 /* LinkedDot */ ||\r\n            currentType === 12 /* LinkedModifier */ ||\r\n            currentType === 10 /* LinkedDelimiter */) &&\r\n            (ch === CHAR_LF || ch === CHAR_SP)) {\r\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\r\n        }\r\n        switch (ch) {\r\n            case \"@\" /* LinkedAlias */:\r\n                scnr.next();\r\n                token = getToken(context, 8 /* LinkedAlias */, \"@\" /* LinkedAlias */);\r\n                context.inLinked = true;\r\n                return token;\r\n            case \".\" /* LinkedDot */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 9 /* LinkedDot */, \".\" /* LinkedDot */);\r\n            case \":\" /* LinkedDelimiter */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 10 /* LinkedDelimiter */, \":\" /* LinkedDelimiter */);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (isLinkedDotStart(scnr, context) ||\r\n                    isLinkedDelimiterStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return readTokenInLinked(scnr, context);\r\n                }\r\n                if (isLinkedModifierStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return getToken(context, 12 /* LinkedModifier */, readLinkedModifier(scnr));\r\n                }\r\n                if (isLinkedReferStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    if (ch === \"{\" /* BraceLeft */) {\r\n                        // scan the placeholder\r\n                        return readTokenInPlaceholder(scnr, context) || token;\r\n                    }\r\n                    else {\r\n                        return getToken(context, 11 /* LinkedKey */, readLinkedRefer(scnr));\r\n                    }\r\n                }\r\n                if (currentType === 8 /* LinkedAlias */) {\r\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\r\n                }\r\n                context.braceNest = 0;\r\n                context.inLinked = false;\r\n                return readToken(scnr, context);\r\n        }\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readToken(scnr, context) {\r\n        let token = { type: 14 /* EOF */ };\r\n        if (context.braceNest > 0) {\r\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n        }\r\n        if (context.inLinked) {\r\n            return readTokenInLinked(scnr, context) || getEndToken(context);\r\n        }\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \"{\" /* BraceLeft */:\r\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n            case \"}\" /* BraceRight */:\r\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\r\n                scnr.next();\r\n                return getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\r\n            case \"@\" /* LinkedAlias */:\r\n                return readTokenInLinked(scnr, context) || getEndToken(context);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                const { isModulo, hasSpace } = detectModuloStart(scnr);\r\n                if (isModulo) {\r\n                    return hasSpace\r\n                        ? getToken(context, 0 /* Text */, readText(scnr))\r\n                        : getToken(context, 4 /* Modulo */, readModulo(scnr));\r\n                }\r\n                if (isTextStart(scnr)) {\r\n                    return getToken(context, 0 /* Text */, readText(scnr));\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    function nextToken() {\r\n        const { currentType, offset, startLoc, endLoc } = _context;\r\n        _context.lastType = currentType;\r\n        _context.lastOffset = offset;\r\n        _context.lastStartLoc = startLoc;\r\n        _context.lastEndLoc = endLoc;\r\n        _context.offset = currentOffset();\r\n        _context.startLoc = currentPosition();\r\n        if (_scnr.currentChar() === EOF) {\r\n            return getToken(_context, 14 /* EOF */);\r\n        }\r\n        return readToken(_scnr, _context);\r\n    }\r\n    return {\r\n        nextToken,\r\n        currentOffset,\r\n        currentPosition,\r\n        context\r\n    };\r\n}\n\nconst ERROR_DOMAIN = 'parser';\r\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\r\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\r\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\r\n    switch (match) {\r\n        case `\\\\\\\\`:\r\n            return `\\\\`;\r\n        case `\\\\\\'`:\r\n            return `\\'`;\r\n        default: {\r\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\r\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\r\n                return String.fromCodePoint(codePoint);\r\n            }\r\n            // invalid ...\r\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\r\n            return '�';\r\n        }\r\n    }\r\n}\r\nfunction createParser(options = {}) {\r\n    const location = options.location !== false;\r\n    const { onError } = options;\r\n    function emitError(tokenzer, code, start, offset, ...args) {\r\n        const end = tokenzer.currentPosition();\r\n        end.offset += offset;\r\n        end.column += offset;\r\n        if (onError) {\r\n            const loc = createLocation(start, end);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function startNode(type, offset, loc) {\r\n        const node = {\r\n            type,\r\n            start: offset,\r\n            end: offset\r\n        };\r\n        if (location) {\r\n            node.loc = { start: loc, end: loc };\r\n        }\r\n        return node;\r\n    }\r\n    function endNode(node, offset, pos, type) {\r\n        node.end = offset;\r\n        if (type) {\r\n            node.type = type;\r\n        }\r\n        if (location && node.loc) {\r\n            node.loc.end = pos;\r\n        }\r\n    }\r\n    function parseText(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(3 /* Text */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseList(tokenizer, index) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(5 /* List */, offset, loc);\r\n        node.index = parseInt(index, 10);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseNamed(tokenizer, key) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(4 /* Named */, offset, loc);\r\n        node.key = key;\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLiteral(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(9 /* Literal */, offset, loc);\r\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinkedModifier(tokenizer) {\r\n        const token = tokenizer.nextToken();\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\r\n        const node = startNode(8 /* LinkedModifier */, offset, loc);\r\n        if (token.type !== 12 /* LinkedModifier */) {\r\n            // empty modifier\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\r\n            node.value = '';\r\n            endNode(node, offset, loc);\r\n            return {\r\n                nextConsumeToken: token,\r\n                node\r\n            };\r\n        }\r\n        // check token\r\n        if (token.value == null) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n        }\r\n        node.value = token.value || '';\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return {\r\n            node\r\n        };\r\n    }\r\n    function parseLinkedKey(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(7 /* LinkedKey */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinked(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const linkedNode = startNode(6 /* Linked */, context.offset, context.startLoc);\r\n        let token = tokenizer.nextToken();\r\n        if (token.type === 9 /* LinkedDot */) {\r\n            const parsed = parseLinkedModifier(tokenizer);\r\n            linkedNode.modifier = parsed.node;\r\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\r\n        }\r\n        // asset check token\r\n        if (token.type !== 10 /* LinkedDelimiter */) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n        }\r\n        token = tokenizer.nextToken();\r\n        // skip brace left\r\n        if (token.type === 2 /* BraceLeft */) {\r\n            token = tokenizer.nextToken();\r\n        }\r\n        switch (token.type) {\r\n            case 11 /* LinkedKey */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\r\n                break;\r\n            case 5 /* Named */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\r\n                break;\r\n            case 6 /* List */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseList(tokenizer, token.value || '');\r\n                break;\r\n            case 7 /* Literal */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\r\n                break;\r\n            default:\r\n                // empty key\r\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\r\n                const nextContext = tokenizer.context();\r\n                const emptyLinkedKeyNode = startNode(7 /* LinkedKey */, nextContext.offset, nextContext.startLoc);\r\n                emptyLinkedKeyNode.value = '';\r\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\r\n                linkedNode.key = emptyLinkedKeyNode;\r\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\r\n                return {\r\n                    nextConsumeToken: token,\r\n                    node: linkedNode\r\n                };\r\n        }\r\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return {\r\n            node: linkedNode\r\n        };\r\n    }\r\n    function parseMessage(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const startOffset = context.currentType === 1 /* Pipe */\r\n            ? tokenizer.currentOffset()\r\n            : context.offset;\r\n        const startLoc = context.currentType === 1 /* Pipe */\r\n            ? context.endLoc\r\n            : context.startLoc;\r\n        const node = startNode(2 /* Message */, startOffset, startLoc);\r\n        node.items = [];\r\n        let nextToken = null;\r\n        do {\r\n            const token = nextToken || tokenizer.nextToken();\r\n            nextToken = null;\r\n            switch (token.type) {\r\n                case 0 /* Text */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseText(tokenizer, token.value || ''));\r\n                    break;\r\n                case 6 /* List */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseList(tokenizer, token.value || ''));\r\n                    break;\r\n                case 5 /* Named */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseNamed(tokenizer, token.value || ''));\r\n                    break;\r\n                case 7 /* Literal */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\r\n                    break;\r\n                case 8 /* LinkedAlias */:\r\n                    const parsed = parseLinked(tokenizer);\r\n                    node.items.push(parsed.node);\r\n                    nextToken = parsed.nextConsumeToken || null;\r\n                    break;\r\n            }\r\n        } while (context.currentType !== 14 /* EOF */ &&\r\n            context.currentType !== 1 /* Pipe */);\r\n        // adjust message node loc\r\n        const endOffset = context.currentType === 1 /* Pipe */\r\n            ? context.lastOffset\r\n            : tokenizer.currentOffset();\r\n        const endLoc = context.currentType === 1 /* Pipe */\r\n            ? context.lastEndLoc\r\n            : tokenizer.currentPosition();\r\n        endNode(node, endOffset, endLoc);\r\n        return node;\r\n    }\r\n    function parsePlural(tokenizer, offset, loc, msgNode) {\r\n        const context = tokenizer.context();\r\n        let hasEmptyMessage = msgNode.items.length === 0;\r\n        const node = startNode(1 /* Plural */, offset, loc);\r\n        node.cases = [];\r\n        node.cases.push(msgNode);\r\n        do {\r\n            const msg = parseMessage(tokenizer);\r\n            if (!hasEmptyMessage) {\r\n                hasEmptyMessage = msg.items.length === 0;\r\n            }\r\n            node.cases.push(msg);\r\n        } while (context.currentType !== 14 /* EOF */);\r\n        if (hasEmptyMessage) {\r\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseResource(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const { offset, startLoc } = context;\r\n        const msgNode = parseMessage(tokenizer);\r\n        if (context.currentType === 14 /* EOF */) {\r\n            return msgNode;\r\n        }\r\n        else {\r\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\r\n        }\r\n    }\r\n    function parse(source) {\r\n        const tokenizer = createTokenizer(source, assign({}, options));\r\n        const context = tokenizer.context();\r\n        const node = startNode(0 /* Resource */, context.offset, context.startLoc);\r\n        if (location && node.loc) {\r\n            node.loc.source = source;\r\n        }\r\n        node.body = parseResource(tokenizer);\r\n        // assert whether achieved to EOF\r\n        if (context.currentType !== 14 /* EOF */) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    return { parse };\r\n}\r\nfunction getTokenCaption(token) {\r\n    if (token.type === 14 /* EOF */) {\r\n        return 'EOF';\r\n    }\r\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\r\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\r\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\r\n) {\r\n    const _context = {\r\n        ast,\r\n        helpers: new Set()\r\n    };\r\n    const context = () => _context;\r\n    const helper = (name) => {\r\n        _context.helpers.add(name);\r\n        return name;\r\n    };\r\n    return { context, helper };\r\n}\r\nfunction traverseNodes(nodes, transformer) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        traverseNode(nodes[i], transformer);\r\n    }\r\n}\r\nfunction traverseNode(node, transformer) {\r\n    // TODO: if we need pre-hook of transform, should be implemented to here\r\n    switch (node.type) {\r\n        case 1 /* Plural */:\r\n            traverseNodes(node.cases, transformer);\r\n            transformer.helper(\"plural\" /* PLURAL */);\r\n            break;\r\n        case 2 /* Message */:\r\n            traverseNodes(node.items, transformer);\r\n            break;\r\n        case 6 /* Linked */:\r\n            const linked = node;\r\n            traverseNode(linked.key, transformer);\r\n            transformer.helper(\"linked\" /* LINKED */);\r\n            transformer.helper(\"type\" /* TYPE */);\r\n            break;\r\n        case 5 /* List */:\r\n            transformer.helper(\"interpolate\" /* INTERPOLATE */);\r\n            transformer.helper(\"list\" /* LIST */);\r\n            break;\r\n        case 4 /* Named */:\r\n            transformer.helper(\"interpolate\" /* INTERPOLATE */);\r\n            transformer.helper(\"named\" /* NAMED */);\r\n            break;\r\n    }\r\n    // TODO: if we need post-hook of transform, should be implemented to here\r\n}\r\n// transform AST\r\nfunction transform(ast, options = {} // eslint-disable-line\r\n) {\r\n    const transformer = createTransformer(ast);\r\n    transformer.helper(\"normalize\" /* NORMALIZE */);\r\n    // traverse\r\n    ast.body && traverseNode(ast.body, transformer);\r\n    // set meta information\r\n    const context = transformer.context();\r\n    ast.helpers = Array.from(context.helpers);\r\n}\n\nfunction createCodeGenerator(ast, options) {\r\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\r\n    const _context = {\r\n        source: ast.loc.source,\r\n        filename,\r\n        code: '',\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        map: undefined,\r\n        breakLineCode,\r\n        needIndent: _needIndent,\r\n        indentLevel: 0\r\n    };\r\n    const context = () => _context;\r\n    function push(code, node) {\r\n        _context.code += code;\r\n    }\r\n    function _newline(n, withBreakLine = true) {\r\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\r\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\r\n    }\r\n    function indent(withNewLine = true) {\r\n        const level = ++_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function deindent(withNewLine = true) {\r\n        const level = --_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function newline() {\r\n        _newline(_context.indentLevel);\r\n    }\r\n    const helper = (key) => `_${key}`;\r\n    const needIndent = () => _context.needIndent;\r\n    return {\r\n        context,\r\n        push,\r\n        indent,\r\n        deindent,\r\n        newline,\r\n        helper,\r\n        needIndent\r\n    };\r\n}\r\nfunction generateLinkedNode(generator, node) {\r\n    const { helper } = generator;\r\n    generator.push(`${helper(\"linked\" /* LINKED */)}(`);\r\n    generateNode(generator, node.key);\r\n    if (node.modifier) {\r\n        generator.push(`, `);\r\n        generateNode(generator, node.modifier);\r\n        generator.push(`, _type`);\r\n    }\r\n    else {\r\n        generator.push(`, undefined, _type`);\r\n    }\r\n    generator.push(`)`);\r\n}\r\nfunction generateMessageNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    generator.push(`${helper(\"normalize\" /* NORMALIZE */)}([`);\r\n    generator.indent(needIndent());\r\n    const length = node.items.length;\r\n    for (let i = 0; i < length; i++) {\r\n        generateNode(generator, node.items[i]);\r\n        if (i === length - 1) {\r\n            break;\r\n        }\r\n        generator.push(', ');\r\n    }\r\n    generator.deindent(needIndent());\r\n    generator.push('])');\r\n}\r\nfunction generatePluralNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    if (node.cases.length > 1) {\r\n        generator.push(`${helper(\"plural\" /* PLURAL */)}([`);\r\n        generator.indent(needIndent());\r\n        const length = node.cases.length;\r\n        for (let i = 0; i < length; i++) {\r\n            generateNode(generator, node.cases[i]);\r\n            if (i === length - 1) {\r\n                break;\r\n            }\r\n            generator.push(', ');\r\n        }\r\n        generator.deindent(needIndent());\r\n        generator.push(`])`);\r\n    }\r\n}\r\nfunction generateResource(generator, node) {\r\n    if (node.body) {\r\n        generateNode(generator, node.body);\r\n    }\r\n    else {\r\n        generator.push('null');\r\n    }\r\n}\r\nfunction generateNode(generator, node) {\r\n    const { helper } = generator;\r\n    switch (node.type) {\r\n        case 0 /* Resource */:\r\n            generateResource(generator, node);\r\n            break;\r\n        case 1 /* Plural */:\r\n            generatePluralNode(generator, node);\r\n            break;\r\n        case 2 /* Message */:\r\n            generateMessageNode(generator, node);\r\n            break;\r\n        case 6 /* Linked */:\r\n            generateLinkedNode(generator, node);\r\n            break;\r\n        case 8 /* LinkedModifier */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 7 /* LinkedKey */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 5 /* List */:\r\n            generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"list\" /* LIST */)}(${node.index}))`, node);\r\n            break;\r\n        case 4 /* Named */:\r\n            generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"named\" /* NAMED */)}(${JSON.stringify(node.key)}))`, node);\r\n            break;\r\n        case 9 /* Literal */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 3 /* Text */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        default:\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                throw new Error(`unhandled codegen node type: ${node.type}`);\r\n            }\r\n    }\r\n}\r\n// generate code from AST\r\nconst generate = (ast, options = {} // eslint-disable-line\r\n) => {\r\n    const mode = isString(options.mode) ? options.mode : 'normal';\r\n    const filename = isString(options.filename)\r\n        ? options.filename\r\n        : 'message.intl';\r\n    const sourceMap = !!options.sourceMap;\r\n    // prettier-ignore\r\n    const breakLineCode = options.breakLineCode != null\r\n        ? options.breakLineCode\r\n        : mode === 'arrow'\r\n            ? ';'\r\n            : '\\n';\r\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\r\n    const helpers = ast.helpers || [];\r\n    const generator = createCodeGenerator(ast, {\r\n        mode,\r\n        filename,\r\n        sourceMap,\r\n        breakLineCode,\r\n        needIndent\r\n    });\r\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\r\n    generator.indent(needIndent);\r\n    if (helpers.length > 0) {\r\n        generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\r\n        generator.newline();\r\n    }\r\n    generator.push(`return `);\r\n    generateNode(generator, ast);\r\n    generator.deindent(needIndent);\r\n    generator.push(`}`);\r\n    const { code, map } = generator.context();\r\n    return {\r\n        ast,\r\n        code,\r\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\r\n    };\r\n};\n\nfunction baseCompile(source, options = {}) {\r\n    const assignedOptions = assign({}, options);\r\n    // parse source codes\r\n    const parser = createParser(assignedOptions);\r\n    const ast = parser.parse(source);\r\n    // transform ASTs\r\n    transform(ast, assignedOptions);\r\n    // generate javascript codes\r\n    return generate(ast, assignedOptions);\r\n}\n\nexport { CompileErrorCodes, ERROR_DOMAIN, LocationStub, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, errorMessages };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}